'''module_name = 'ieee_adder'
file_input = 'ieee_stages.v'
file_output = 'ieee_adder.v'
clock_name = 'clock_in'
inputs = [('bit','add_sub_bit'), ('number','inputA'), ('number','inputB'), ('bit', clock_name)]
outputs = [('number','outputC')]
'''
from __future__ import print_function
module_name = 'emir'
file_input = 'emir_stages.v'
file_output = 'emir_gen.v'
clock_name = 'clock_in'

types = {
	'bit' : '',
	'w3' : '[0:2]',
}
inputs = [('bit','A'), ('bit','B'), ('bit', clock_name)]
outputs = [('bit','Z'),('bit','Y')]

import re
import string
import random
import sys
from parselib import readNoComments, readModules
from copy import copy

out = open(file_output,'w')
out.write("////////////////////////////////////////////\n")
out.write("//                                        //\n")
out.write("//  THIS FILE IS AUTOMATICALLY GENERATED  //\n")
out.write("//     BY generate.py, DO NOT EDIT!       //\n")
out.write("//                                        //\n")
out.write("////////////////////////////////////////////\n")
out.write('`include "src/defines.v"\n')

out.write("module "+module_name+"(" + 
	",".join(name for type, name in inputs + outputs) + ")\n")

for type,input in inputs:
	out.write("\tinput "+types[type]+" " + input + ";\n")

for type,output in outputs:
	out.write("\toutput "+types[type]+" " + output + ";\n")

file = readNoComments(open(file_input))
modules = readModules(file, module_name, types)
modules['__input_stage__'] = {
	'name':'__input_stage__',
	'inputs':[],
	'outputs' : inputs, #imaginary module which provides module inputs
}

stages = [
	{ #Stage 0
		'components':[
			{'name':'__input_stage__'},
		],
		'add_ffs' : False,
	},
	{ #Stage 1
		'components':[
			{'name':'module3'},
			{'name':'module2','suffix':'A','override_input':{'D':'D1'}},
			{'name':'module2','suffix':'B','override_input':{'D':'D2'}},
			{'name':'module1'},
		],
		'add_ffs' : False,
	},
]

#populate var_appear and comp_appear
var_appear = {}
comp_appear = {}
for stage_num, stage in enumerate(stages):
	for component in stage['components']:
		name = component['name']
		module = modules[name]
		if 'suffix' in component:
			name += component['suffix']
		
		#check for a duplicate component
		if name in comp_appear:
			raise Exception('Duplicate name module "%s"' % name)
		map_inputs = {}
		minputs = []
		override = component['override_input'] if 'override_input' in component else None
		for type, input in module['inputs']:
			print(name, ' input ', input)
			if override and input in override:
				input_name = override[input]
			else:
				input_name = input
			map_inputs[input_name] = input
			minputs.append((type, input_name))
		
		comp_appear[name] = {
			'stage':stage_num,
			'module_name':name,
			'inputs':minputs,
			'map_inputs':map_inputs,
			'added':False,
			'on_stack':False,
		}
		#for all outputs in this instance of module
		for type, output_orig in module['outputs']:
			output = output_orig
			if 'suffix' in component:
				output += component['suffix']
			if output not in var_appear:
				var_appear[output] = []
			else:
				#check if there is collision?
				if var_appear[-1]['stage'] == stage_num:
					raise Exception("Duplicate output %s in stage %d" %
						(output, stage_num))
			#add output to var_appear
			var_appear[output].append({
					'stage':stage_num,
					'name':name,
					'module_name':component['name'],
					'output_name':output_orig,
					'type':type,
					'end_stage':stage_num,
				})

def find_next_var(name, var_appear, start_stage):
	if name not in var_appear:
		return None
	for var in reversed(var_appear[name]):
		if var['stage'] <= start_stage:
			return var
	return None

def add_to_stack(variables, stack, stage_num):
	count = 0
	for type, output in variables:
		var = find_next_var(output, var_appear, stage_num)
		if var is None:
			raise Exception("%s not found" % output)
		else:
			var['end_stage'] = max(var['end_stage'], stage_num)
			name = var['name']
			if name not in comp_appear:
				raise Exception("%s not in comp_appear"%name)
			module_name = var['module_name']
			stage = var['stage']
			if not comp_appear[name]['on_stack']:
				stack.append(name)
				comp_appear[name]['on_stack'] = True
				count += 1
	return count

#add outputs to processing stack
stack = []
add_to_stack(outputs, stack, len(stages))
while len(stack) > 0:
	name = stack[-1]
	if comp_appear[name]['added']:
		stack.pop()
		continue
	
	count = add_to_stack(comp_appear[name]['inputs'], stack, comp_appear[name]['stage'])
	if count == 0:
		print('adding module',name)
		stack.pop()

for name in comp_appear:
	print('comp',name)
	print(comp_appear[name])
for name in var_appear:
	print('var', name, end=" ")
	print(var_appear[name])
out.write("endmodule\n")

'''
///////////////////////////////
// MODULE: ieee_adder_step1
///////////////////////////////
//
// Connect all stages together
//
///////////////////////////////

	//These are outputs of Stage 1
	wire s1o_signA;
	wire s1o_signB;
	wire [`EXPO_LEN-1:0] s1o_exponentA;
	wire [`EXPO_LEN-1:0] s1o_exponentB;
	wire [`SIGNIFICAND_LEN:-`GUARDBITS] s1o_significandA;
	wire [`SIGNIFICAND_LEN:-`GUARDBITS] s1o_significandB;
	
	//Call Stage 1
	ieee_adder_prepare_input S1_PREP_A(
		.add_sub_bit  (1'b0),//A has + in front
		.number       (inputA),
		.sign         (s1o_signA),
		.exponent     (s1o_exponentA),
		.significand  (s1o_significandA)
	);
	ieee_adder_prepare_input S1_PREP_B(
		.add_sub_bit   (add_sub_bit),//B might have a - sign in front
		.number        (inputB),
		.sign          (s1o_signB),
		.exponent      (s1o_exponentB),
		.significand   (s1o_significandB)
	);
	
	//Connect Stage 1 with Stage 2
	`ifdef REG_S1_TO_S2
		`include "src/connect_reg.v"
	`else
		`include "src/connect_wire.v"
	`endif
	
	`S_TYPE s2i_signA;
	`S_TYPE s2i_signB;
	`S_TYPE [`EXPO_LEN-1:0] s2i_exponentA;
	`S_TYPE [`EXPO_LEN-1:0] s2i_exponentB;
	`S_TYPE [`SIGNIFICAND_LEN:-`GUARDBITS] s2i_significandA;
	`S_TYPE [`SIGNIFICAND_LEN:-`GUARDBITS] s2i_significandB;
	
	`S_BEGIN
		`S_ASSIGN s2i_signA        = s1o_signA;
		`S_ASSIGN s2i_signB        = s1o_signB;
		`S_ASSIGN s2i_exponentA    = s1o_exponentA;
		`S_ASSIGN s2i_exponentB    = s1o_exponentB;
		`S_ASSIGN s2i_significandA = s1o_significandA;
		`S_ASSIGN s2i_significandB = s1o_significandB;
	`S_END
	
	//These are outputs of Stage 2
	wire s2o_expA_bigger_expB;
	wire s2o_inputA_bigger_inputB;
	wire [`EXPO_LEN-1:0] s2o_shift_amount;
	wire [`SIGNIFICAND_LEN:-`GUARDBITS] s2o_significandA;
	wire [`SIGNIFICAND_LEN:-`GUARDBITS] s2o_significandB;
	
	//copy some data directly
	assign s2o_significandA = s2i_significandA;
	assign s2o_significandB = s2i_significandB;
	assign s2o_exponentA = s2i_exponentA;
	assign s2o_exponentB = s2i_exponentB;
	
	//Call the stage 2
	ieee_adder_compare S2_COMP_AB(
		.exponentA           (s2i_exponentA),
		.exponentB           (s2i_exponentB),
		.significandA        (s2i_significandA),
		.significandB        (s2i_significandB),
		.expA_bigger_expB    (s2o_expA_bigger_expB),
		.inputA_bigger_inputB(s2o_inputA_bigger_inputB),
		.shift_amount        (s2o_shift_amount)
	);
	
	//Connect Stage 2 with Stage 3
	`ifdef REG_S2_TO_S3
		`include "src/connect_reg.v"
	`else
		`include "src/connect_wire.v"
	`endif
	
	`S_TYPE s3i_expA_bigger_expB;
	`S_TYPE [`EXPO_LEN-1:0] s3i_shift_amount;
	`S_TYPE [`SIGNIFICAND_LEN:-`GUARDBITS] s3i_significandA;
	`S_TYPE [`SIGNIFICAND_LEN:-`GUARDBITS] s3i_significandB;
	`S_BEGIN
		`S_ASSIGN s3i_expA_bigger_expB = s2o_expA_bigger_expB;
		`S_ASSIGN s3i_shift_amount     = s2o_shift_amount;
		`S_ASSIGN s3i_significandA     = s2o_significandA;
		`S_ASSIGN s3i_significandB     = s2o_significandB;
	`S_END
	
	//Call stage 3
	ieee_adder_stage3 S3 (
		.significandA     (s3i_significandA),
		.significandB     (s3i_significandB),
		.shift_amount     (s3i_shift_amount),
		.expA_bigger_expB (s3i_expA_bigger_expB),
		.outputC          (outputC)
	);
	
endmodule


'''
